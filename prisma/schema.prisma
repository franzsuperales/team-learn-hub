// // This is your Prisma schema file,
// // learn more about it in the docs: https://pris.ly/d/prisma-schema

// // Looking for ways to speed up your queries, or scale easily with your serverless or edge functions?
// // Try Prisma Accelerate: https://pris.ly/cli/accelerate-init

// generator client {
//   provider = "prisma-client-js"
// }

// datasource db {
//   provider = "postgresql"
//   url      = env("DATABASE_URL")
// }

// model User {
//   id        String  @id @default(cuid())
//   fname     String
//   lname     String
//   email     String
//   password  String
//   activated Boolean @default(false)
// }

// model VerificationToken {
//   id      String   @id @default(cuid())
//   email   String
//   token   String
//   expires DateTime @map("expires_at")

//   @@unique([email, token])
// }

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

generator client {
  provider = "prisma-client-js"
}

enum Role {
  USER
  ADMIN
}

enum MaterialStatus {
  PENDING
  APPROVED
  REJECTED
}

model User {
  id            String    @id @default(cuid())
  fname         String
  lname         String
  email         String    @unique
  password      String
  role          Role      @default(USER)
  bio           String?
  emailVerified DateTime?

  // Optional for WebAuthn support
  // Authenticator Authenticator[]

  createdAt   DateTime      @default(now())
  updatedAt   DateTime      @updatedAt
  Post        Post[]
  materialUrl MaterialUrl[]
  Bookmark    Bookmark[]
}

// model Account {
//   userId            String
//   type              String
//   provider          String
//   providerAccountId String
//   refresh_token     String?
//   access_token      String?
//   expires_at        Int?
//   token_type        String?
//   scope             String?
//   id_token          String?
//   session_state     String?

//   createdAt DateTime @default(now())
//   updatedAt DateTime @updatedAt

//   user User @relation(fields: [userId], references: [id], onDelete: Cascade)

//   @@id([provider, providerAccountId])
// }

// model Session {
//   sessionToken String   @unique
//   userId       String
//   expires      DateTime
//   user         User     @relation(fields: [userId], references: [id], onDelete: Cascade)

//   createdAt DateTime @default(now())
//   updatedAt DateTime @updatedAt
// }

model VerificationToken {
  identifier String
  token      String
  expires    DateTime

  @@id([identifier, token])
}

model ResetToken {
  token      String   @unique
  identifier String
  expires    DateTime
}

// Optional for WebAuthn support
// model Authenticator {
//   credentialID         String  @unique
//   userId               String
//   providerAccountId    String
//   credentialPublicKey  String
//   counter              Int
//   credentialDeviceType String
//   credentialBackedUp   Boolean
//   transports           String?

//   user User @relation(fields: [userId], references: [id], onDelete: Cascade)

//   @@id([userId, credentialID])
// }

model Category {
  id   String @id @default(cuid())
  name String @unique

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
  Post      Post[]

  @@index([id])
}

model Post {
  id          String         @id @default(cuid())
  title       String
  description String?
  status      MaterialStatus @default(PENDING)
  authorId    String
  categoryId  String
  author      User           @relation(fields: [authorId], references: [id], onDelete: Cascade)
  category    Category       @relation(fields: [categoryId], references: [id], onDelete: Cascade)

  createdAt   DateTime      @default(now())
  updatedAt   DateTime      @updatedAt
  materialUrl MaterialUrl[]
  Bookmark    Bookmark[]

  @@index([id])
}

model MaterialUrl {
  id     String @id @default(cuid())
  url    String
  name   String
  type   String
  postId String
  userId String

  post   Post  @relation(fields: [postId], references: [id], onDelete: Cascade)
  author User? @relation(fields: [userId], references: [id])

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@index([id])
}

model Bookmark {
  id     String @id @default(cuid())
  postId String
  userId String

  user User? @relation(fields: [userId], references: [id], onDelete: Cascade)
  post Post? @relation(fields: [postId], references: [id], onDelete: Cascade)

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@unique([postId, userId])
  @@index([id])
}
